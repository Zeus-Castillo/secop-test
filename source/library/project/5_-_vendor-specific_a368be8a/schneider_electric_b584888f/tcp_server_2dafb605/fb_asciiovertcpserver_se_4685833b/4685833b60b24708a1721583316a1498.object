{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)4685833b-60b2-4708-a172-1583316a1498","ParentGuid":"(Guid)00000000-0000-0000-0000-000000000000","Name":"(string)FB_ASCIIoverTCPserver_SE","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)24568a24-c491-472c-a21f-ee5d33859fab","@Value":{"@Type":"24568a24","@Value":{"MemoryReserveForOnlineChange":"(int)0","ExcludeFromBuild":"(bool)False","External":"(bool)False","EnableSystemCall":"(bool)False","CompilerDefines":"(string)","LinkAlways":"(bool)False","Undefines":{"@Type":"[string]","@Value":[]}}}},{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)21af5390-2942-461a-bf89-951aaf6999f1","@Value":"(Guid)2dafb605-a200-4588-8ce1-ce3cd1f1bc02"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"24568a24":"{24568a24-c491-472c-a21f-ee5d33859fab}","2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","bool":"System.Boolean","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","int":"System.Int32","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)\n(* TCP Server state *)\netTcpServerState\t\t:= fbTcpServer.State;\nxDataToReadAvailable\t:= fbTcpServer.IsDataAvailable;\nxNewConnectionAvailable\t:= fbTcpServer.IsNewConnectionAvailable;\n\n(* Cyclically check the client connections and update the list of connected clients *)\nfbTcpServer.CheckClients();\nastConnectedClientsTcpLib := fbTcpServer.ConnectedClients2;\nuiNbOfClientsTcpLib\t\t:= fbTcpServer.NumberOfConnectedClients;\n\n(* Update the local list of connected clients *)\nA_UpdateListOfConnectedClients();\n\n(* Check the Ethernet Status of the controller *)\nIF NOT i_xEnable THEN\n\tiState\t\t\t:= 0;\t// stay in Idle\nELSIF NOT i_xEthIfReady THEN\n\txInterruptEth\t:= xPortOpen;\n\txPortOpen\t\t:= FALSE;\t// reset the status flag\n\tiState\t\t\t:= 100;\t// go into state 100 - do nothing\nELSE\n\tIF (iState = 100) THEN\n\t\tIF (fbTcpServer.State <> TCPUDP.ET_State.Idle) THEN\n\t\t\tiState\t:= 50;\n\t\tELSE\n\t\t\tiState\t:= 0;\n\t\tEND_IF\n\tEND_IF\n\txInterruptEth\t:= FALSE;\nEND_IF\n\n(* Function block inputs *)\n(* Monitor rising edges of commands *)\nfbRTrigListen\t\t(CLK:= i_xCmdListen);\nfbRTrigClose\t\t(CLK:= i_xCmdClose);\nfbRTrigDisconnectAll(CLK:= i_xCmdDisconnectAll);\nfbRTrigClearResult\t(CLK:= i_xCmdClearResult);\nsIpAddrServer\t\t\t\t:= i_sIpAddrServer;\nuiTcpPortListen\t\t\t\t:= i_uiTcpServerPort;\ntimTimeoutInactivity\t\t:= i_timTimeoutInactivity;\nIF iState = 0 OR xFirstCycle THEN\n\txUseTls\t\t\t\t\t\t\t:= i_xTlsSelected;\n\tstTlsSettings.etCertVerifyMode\t:= i_etCertVerifyMode;\nEND_IF\n\n(* Clear the result *)\nIF fbRTrigClearResult.Q OR (fbRTrigListen.Q AND iState = 0) OR NOT i_xEnable THEN\n\t// reset all alarms and warnings\n\txAlarmAccept\t\t\t:= FALSE;\n\txAlarmClose\t\t\t\t:= FALSE;\n\txAlarmDisconnect\t\t:= FALSE;\n\txAlarmDisconnectAll\t\t:= FALSE;\n\txAlarmOpen\t\t\t\t:= FALSE;\n\txAlarmReceive\t\t\t:= FALSE;\n\txAlarmSend\t\t\t\t:= FALSE;\n\txWarnMaxNbOfClients\t\t:= FALSE;\n\txWarnSend\t\t\t\t:= FALSE;\n\txWarnLenOfDataReceived\t:= FALSE;\n\txUnexpectedData \t\t:= FALSE;\t\n\tfbTcpServer.ResetResult();\n\tetTcpServerResult\t\t:= TCPUDP.ET_Result.Ok;\t\n\tsStepFailed\t\t\t\t:='';\nEND_IF\n\n// Check if there is data to be sent\nxThereIsDataToSend := FALSE;\nFOR uiLoop := 1 TO TCPUDP.GPL.Gc_uiTCPServerMaxConnections DO\n\tIF iq_astClientInfo[uiLoop].axPushData THEN\n\t\txThereIsDataToSend := TRUE;\n\t\tEXIT;\n\tEND_IF\nEND_FOR\n\n\nIF fbRTrigClose.Q THEN\t// request to close the port\n\tiState\t:= 50;\nEND_IF\n\nCASE iState OF\n\t0:\t(* Wait for the command to open the selected port *)\n\t\txPortOpen\t:= FALSE;\n\t\tIF i_xEnable AND (etTcpServerState <> TCPUDP.ET_State.Idle) THEN\n\t\t\tiState\t:= 50;\t// close an open port first\n\t\tELSIF i_xEnable AND fbRTrigListen.Q THEN\n\t\t\tA_OpenPort();\n\t\tEND_IF\n\t\t\n\t5: (* Process opening procedure *)\n\t\tA_OpeningPort();\n\t\t\n\t10:\t(* Check for incoming connections & incomming data from connected clients *)\n\t\tIF xNewConnectionAvailable AND uiNbOfClientsTcpLib>=TCPUDP.GPL.Gc_uiTCPServerMaxConnections THEN\n\t\t\txWarnMaxNbOfClients\t:= TRUE;\n\t\tEND_IF\n\t\tIF xNewConnectionAvailable AND NOT xWarnMaxNbOfClients THEN\n\t\t\tA_AcceptConnection();\n\t\t(* Data Exchange *)\n\t\tELSIF xThereIsDataToSend THEN \n\t\t\tA_DataSend();\n\t\tELSIF xDataToReadAvailable AND (etTcpServerResult = TCPUDP.ET_Result.Ok) THEN\n\t\t\tA_DataReceive();\n\t\tEND_IF\n\t\t\t\t\n\t\t(* Inactivity Monitoring *)\n\t\tA_InactivityMonitor();\n\t\t\n\t\t(* Disconnect commands *)\n\t\tIF fbRTrigDisconnectAll.Q THEN\t// Disconnect all clients\n\t\t\tA_DisconnectAllClients();\t\t\t\t\t\n\t\tEND_IF\n\t\n\t15: (* Process accepting procedure *)\n\t\tA_AcceptingConnection();\n\t\n\t50:\t(* Close the port *)\n\t\t// uiOpenIncomingPort := FC_BlockIncomingTcpPort(uiOpenIncomingPort);\n\t\tA_Close();\n\t\t\n\t55:\t(* Process closing procedure *)\n\t\tA_Closing();\n\t\t\n\t100:(* Ethernet Interface of the controller not ready *)\n\t\t;\t// do nothing\n\t\nEND_CASE\n\n(* Create diagnostic message *)\nIF NOT i_xEnable THEN\t\t\n\tsDiagMessage\t:= 'Tcp Server disabled';\n\txDiag\t\t\t:= FALSE;\t\nELSIF (iState = 100) THEN\t\t\n\tsDiagMessage\t:= 'Ethernet link not ready';\n\txDiag\t\t\t:= TRUE;\t\nELSIF xAlarmOpen THEN\t\t\n\tsDiagMessage\t:= 'Port open failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmAccept THEN\t\t\n\tsDiagMessage\t:= 'Accept incomming connection failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmReceive THEN\t\t\n\tsDiagMessage\t:= 'Receiving data from a specific client failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmSend THEN\t\t\n\tsDiagMessage\t:= 'Send response to client failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmDisconnect THEN\t\t\n\tsDiagMessage\t:= 'Disconnection of a specific client failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmDisconnectAll THEN\t\t\n\tsDiagMessage\t:= 'Command disconnect all clients failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xAlarmClose THEN\t\t\n\tsDiagMessage\t:= 'Close connection failed';\n\txDiag\t\t\t:= TRUE;\nELSIF xWarnMaxNbOfClients THEN\t\t\n\tsDiagMessage\t:= 'Accept failed - maximum number of clients connected';\n\txDiag\t\t\t:= TRUE;\nELSIF xWarnLenOfDataReceived THEN\t\t\n\tsDiagMessage\t:= 'Length of received data inconsistant';\n\txDiag\t\t\t:= TRUE;\nELSIF xWarnSend THEN\t\t\n\tsDiagMessage\t:= 'Sending of data incomplete';\n\txDiag\t\t\t:= TRUE;\nELSIF xUnexpectedData THEN\n\tsDiagMessage\t:= 'Unexpected data from client. TCP reception buffer full. Client disconnected';\n\txDiag\t\t\t:= TRUE;\t\nELSE\t\t\t\n\tsDiagMessage\t:= 'No alarm or warning';\n\txDiag\t\t\t:= FALSE;\nEND_IF\nIF xDiag THEN\n\tq_sLastErrorDiagMessage := sDiagMessage;\nEND_IF\n\n(* Function block outputs *)\nq_sTcpServerState := TCPUDP.FC_EtStateToString(i_etState:= etTcpServerState);\nIF xAlarmSend AND etTcpServerResult = TCPUDP.ET_Result.Ok THEN\n\tq_sTcpServerResult\t\t:= Standard.CONCAT(sStepFailed, TCPUDP.FC_EtResultToString(i_etResult:= TCPUDP.ET_Result.ClosedByPeer));\nELSE\n\tq_sTcpServerResult\t\t:= Standard.CONCAT(sStepFailed, TCPUDP.FC_EtResultToString(i_etResult:= etTcpServerResult));\nEND_IF\n\nq_xDiag\t\t\t\t\t\t:= xDiag;\nq_sDiagMessage\t\t\t\t:= sDiagMessage;\nq_xPortOpen\t\t\t\t\t:= xPortOpen;\nq_uiNbOfConnectedClients\t:= uiNbOfClientsTcpLib;\nq_astConnectedClients\t\t:= astConnectedClientsTcpLib;\n\nIF xDisconnectDone THEN\n\t// update the flag in case disconnection was done automatically by the progam\n\txDisconnectDone\t:= FALSE;\nEND_IF\n\n(* reset the first cycle information *)\nxFirstCycle\tR= xFirstCycle;","LineInfoPersistence":"(string)4685833b-60b2-4708-a172-1583316a1498_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)FUNCTION_BLOCK FB_ASCIIoverTCPserver_SE\nVAR_INPUT\n\t/// Enable FB operation\n\ti_xEnable: BOOL;\n\t/// Ethernet interface ready\n\ti_xEthIfReady: BOOL;\n\t/// Start listening to incoming connections on rising edge\n\ti_xCmdListen: BOOL;\n\t/// Stop listening (close port) on rising edge\n\ti_xCmdClose: BOOL;\n\t/// Disconnect all clients on rising edge\n\ti_xCmdDisconnectAll: BOOL;\n\t/// Clear last diagnostic messages and alarms on rising edge\n\ti_xCmdClearResult: BOOL;\n\t/// TCP server IP address\n\ti_sIpAddrServer: STRING(15);\n\t/// TCP server port\n\ti_uiTcpServerPort: UINT;\n\t/// Clients inactivity timeout before being disconnected\n\ti_timTimeoutInactivity: TIME;\n\t/// When TRUE uses TLS certificate for secured connection when opening the port. Refer to method OpenTls in Schneider's TCPUDP library\n\ti_xTlsSelected: BOOL;\n\t/// 1:NotVerified, 4:AllCertificates, 6:TrustedOnly. Refer to ENUM ET_CertVerifyMode in Schneider's TCPUDP library\n\ti_etCertVerifyMode: TCPUDP.ET_CertVerifyMode;\nEND_VAR\nVAR_OUTPUT\n\t/// Connected clients information. Refer to structure ST_ClientConnection2 in Schneider's TCPUDP library\n\tq_astConnectedClients: ARRAY[1..TCPUDP.GPL.Gc_uiTCPServerMaxConnections] OF TCPUDP.ST_ClientConnection2;\n\t/// Number of connected clients\n\tq_uiNbOfConnectedClients: UINT;\n\t/// Server port status. When TRUE the port is open (server is listening)\n\tq_xPortOpen: BOOL;\n\t/// Server diagnostic message\n\tq_sDiagMessage: STRING;\n\t/// When TRUE, an alarm is active and a diagnostic message is available\n\tq_xDiag: BOOL;\n\t/// Server current state. Refer to ENUM ET_State in Schneider's TCPUDP library\n\tq_sTcpServerState: STRING;\n\t/// Server result of last transaction. Refer to ENUM ET_Result in Schneider's TCPUDP library\n\tq_sTcpServerResult: STRING;\n\t/// Last registered diagnostic message\n\tq_sLastErrorDiagMessage: STRING;\nEND_VAR\nVAR_IN_OUT\n\t/// list of connected clients including the timestamp for inactivity monitoring and data exchange information\n\tiq_astClientInfo: ARRAY[1..TCPUDP.GPL.Gc_uiTCPServerMaxConnections] OF ST_ClientInfo_SE;\nEND_VAR\nVAR\n\t/// IP address of the Eth interface where to listen\n\tsIpAddrServer: STRING(15);\n\t/// TCP Port for incomming connections\n\tuiTcpPortListen: UINT;\n\t/// IP address of the TCP client connected\n\tsIpAddrClient: STRING(15);\n\t/// Port of accepted client\n\tuiTcpPortClient: UINT;\n\t/// Number of connected clients\n\tuiNbOfClientsTcpLib: UINT;\n\t/// Timeout to disconnet a client automatically in case of inactivity\n\ttimTimeoutInactivity: TIME := TIME#30s0ms;\n\t/// TLS settings. Refer to structure ST_TlsSettingsServer in Schneider's TCPUDP library\n\tstTlsSettings: TcpUdp.ST_TlsSettingsServer;\n\t/// Copy of input i_xTlsSelected\n\txUseTls: BOOL;\n\t/// Ip address of client to disconnect\n\tsIpAddrClientToDisconnect: STRING(15);\n\t/// Port number of client to disconnect\n\tuiPortClientToDisconnect: UINT;\n\t/// indicates the Ethernet was disturbed, while the TCP port was open\n\txInterruptEth: BOOL;\n\t/// state of the TCP connection\n\tetTcpServerState: TCPUDP.ET_State;\n\t/// result of the latest method call\n\tetTcpServerResult: TCPUDP.ET_Result;\n\t/// indicates a new incoming connection is available\n\txNewConnectionAvailable: BOOL;\n\t/// indicates that data are available to read\n\txDataToReadAvailable: BOOL;\n\t/// operation flags\n\txPortOpen: BOOL;\n\txOpenDone: BOOL;\n\txAcceptDone: BOOL;\n\txCloseDone: BOOL;\n\txDisconnectDone: BOOL;\n\txDisconnectAllDone: BOOL;\n\t/// Number of bytes sent to the server using the method Send\n\tudiSentData: UDINT;\n\t/// Number of bytes read from the buffer using the method Receive\n\tudiSizeReceivedData: UDINT;\n\t/// Alarm: Open failed\n\txAlarmOpen: BOOL;\n\t/// Alarm: Accept failed\n\txAlarmAccept: BOOL;\n\t/// Alarm: Receive method\n\txAlarmReceive: BOOL;\n\t/// Alarm: not all bytes have been sent\n\txAlarmSend: BOOL;\n\t/// Alarm: Disconnect a specific client failed\n\txAlarmDisconnect: BOOL;\n\t/// Alarm: Disconnect all clients failed\n\txAlarmDisconnectAll: BOOL;\n\t/// Alarm: Close the port failed\n\txAlarmClose: BOOL;\n\t/// Warning: Maximum number of clients are connected - no new connection possible\n\txWarnMaxNbOfClients: BOOL;\n\t/// Warning: Data length in received data doesn't meet the number of bytes available to read\n\txWarnLenOfDataReceived: BOOL;\n\t/// Warning: Not all data have been sent\n\txWarnSend: BOOL;\n\t/// Indicates a Diag message is available\n\txDiag: BOOL;\n\t/// Diag message created from the alarms and warnings\n\tsDiagMessage: STRING;\n\t/// String contains the name of the Step or Method which is failed to precise the result message \n\tsStepFailed: STRING;\n\t/// current state of the state machine\n\tiState: INT;\n\t/// list of connected clients\n\tastConnectedClientsTcpLib: ARRAY[1..TCPUDP.GPL.Gc_uiTCPServerMaxConnections] OF TCPUDP.ST_ClientConnection2;\n\t/// Data to receive/send to specified client\n\tstDataReceive: ST_ServerData_SE;\n\t/// Data to receive/send to specified client\n\tstDataSend: ST_ServerData_SE;\n\t/// send buffer\n\tabySendBuffer: ARRAY[0..GPL_TcpServer_SE.Gc_uiDataTransferChunkSize] OF BYTE;\n\t/// receive buffer\n\tabyReceiveBuffer: ARRAY[0..GPL_TcpServer_SE.Gc_uiDataTransferChunkSize] OF BYTE;\n\t/// fill level of the receive buffer\n\tudiFillLevelReceive: UDINT;\n\t/// max number of Bytes to be read using the Receive method, !!! Must not be greater than the Buffer size! !!!\n\tudiReceiveBufferSize: UDINT;\n\t/// fill level of the send buffer\n\tudiFillLevelSend: UDINT;\n\t/// FB Instances\n\tfbTcpServer: TCPUDP.FB_TCPServer2;\n\tfbRTrigListen: Standard.R_TRIG;\n\tfbRTrigClose: Standard.R_TRIG;\n\tfbRTrigDisconnectAll: Standard.R_TRIG;\n\tfbRTrigClearResult: Standard.R_TRIG;\n\t/// auxiliary flags and variables\n\tuiLoop: UINT;\n\t/// auxiliary flags and variables\n\tuiLoopLib: UINT;\n\txClientFound: BOOL;\n\ttimCurrTimestamp: TIME;\n\ttimStartCheckInactiviy: TIME;\n\txFirstCycle: BOOL := TRUE;\n\txUnexpectedData: BOOL;\n\tuiNoOfBytesRead: UINT;\n\tuiNoOfBytesWritten: UINT;\n\txThereIsDataToSend: BOOL;\nEND_VAR\n","LineInfoPersistence":"(string)4685833b-60b2-4708-a172-1583316a1498_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)957","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}